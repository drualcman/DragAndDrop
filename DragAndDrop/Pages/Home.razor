@page "/"
@using DragAndDrop.Models
@using DragAndDrop.Shared
@using DragAndDrop.Utils
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Blazor Drag & Drop Report Builder</PageTitle>

<div class="report-builder-container">
    <!-- Paleta de Herramientas -->
    <div class="toolbox">
        <h4>Herramientas</h4>
        @foreach(var vizType in Enum.GetValues<VisualizationType>())
        {
            <div id="tool-@vizType" class="tool-item" @ref="toolElements[vizType]"
                 style="background-color: @ColorHelper.GetColorForVisualization(vizType, 0.1); border: 1px solid @ColorHelper.GetColorForVisualization(vizType);">
                @vizType.ToString()
            </div>
        }
        <hr />
        <button class="btn btn-danger mt-3 w-100" @onclick="ClearReport">Limpiar Reporte</button>
    </div>

    <!-- Lienzo del Reporte -->
    <div class="report-canvas-wrapper">
        <div id="main-canvas" class="report-canvas drop-zone" @ref="dropZoneElement">
            @if(!reportRows.Any())
            {
                <div class="empty-canvas-message">Arrastra una herramienta aquí para comenzar</div>
            }
            @foreach(var row in reportRows)
            {
                <ReportItemView Item="row" OnDeleteItemRequest="HandleDeleteItem" />
            }
        </div>
    </div>
</div>

@code {
    private List<TemplateExecutionModel> reportRows = new();
    private DotNetObjectReference<Home>? dotNetRef;
    private Dictionary<VisualizationType, ElementReference> toolElements = new();
    private ElementReference dropZoneElement;

    protected override void OnInitialized()
    {
        foreach(var vizType in Enum.GetValues<VisualizationType>().Where(v => v != VisualizationType.Empty))
        {
            toolElements[vizType] = new ElementReference();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("blazorDragDrop.setDotNetHelper", dotNetRef);

            foreach(var (vizType, element) in toolElements)
            {
                // El dato que se arrastra es de tipo 'Tool'
                var dragData = new { DragType = "Tool", Type = vizType.ToString() };
                await JSRuntime.InvokeVoidAsync("makeDraggable", element, dragData);
            }

            await JSRuntime.InvokeVoidAsync("makeDropZone", dropZoneElement);
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void HandleDrop(object droppedDataObject, string targetId, string dropPosition)
    {
        var droppedData = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(droppedDataObject.ToString());
        Console.WriteLine(droppedData);
        string dragType = droppedData.GetProperty("dragType").GetString() ?? "";

        if(dragType == "Tool")
        {
            // Lógica para añadir una nueva herramienta
            HandleNewToolDrop(droppedData.GetProperty("type").GetString() ?? "", targetId, dropPosition);
        }
        else if(dragType == "Item")
        {
            // Lógica para mover un item existente
            HandleMoveItemDrop(Guid.Parse(droppedData.GetProperty("itemId").GetString() ?? ""), Guid.Parse(targetId), dropPosition);
        }
        StateHasChanged();
    }

    private void HandleNewToolDrop(string vizTypeString, string targetId, string dropPosition)
    {
        Enum.TryParse(vizTypeString, out VisualizationType vizType);
        var newItem = new TemplateExecutionModel { Visualization = vizType, Name = vizType.ToString() };

        if(targetId == "main-canvas")
        {
            var newRow = new TemplateExecutionModel { Visualization = VisualizationType.Empty, Name = "Nueva Fila" };
            newRow.Items.Add(newItem);
            reportRows.Add(newRow);
            return;
        }

        var targetItem = FindItemById(Guid.Parse(targetId));
        if(targetItem == null)
            return;

        InsertItem(newItem, targetItem, dropPosition);
    }

    private void HandleMoveItemDrop(Guid sourceId, Guid targetId, string dropPosition)
    {
        var sourceItem = FindItemById(sourceId);
        var targetItem = FindItemById(targetId);

        if(sourceItem == null || targetItem == null || sourceId == targetId || IsDescendant(sourceItem, targetId))
            return;

        // 1. Eliminar el item de su posición original
        var parent = sourceItem.Parent;
        parent?.Items.Remove(sourceItem);
        CleanupEmptyParent(parent);

        // 2. Insertar el item en la nueva posición
        InsertItem(sourceItem, targetItem, dropPosition);
    }

    private void InsertItem(TemplateExecutionModel itemToInsert, TemplateExecutionModel targetItem, string dropPosition)
    {
        if(dropPosition == "Center")
        {
            // Solo se puede soltar en el centro si el destino es una fila (Empty)
            if(targetItem.Visualization == VisualizationType.Empty)
            {
                targetItem.Items.Add(itemToInsert);
            }
            else // Si se suelta en el centro de una columna, la reestructura
            {
                var parent = targetItem.Parent;
                if(parent != null)
                {
                    var newSubRow = new TemplateExecutionModel { Visualization = VisualizationType.Empty, Name = "Fila anidada" };
                    // Clonar el item existente para no perder sus hijos si los tuviera
                    var oldItemClone = new TemplateExecutionModel { Visualization = targetItem.Visualization, Name = targetItem.Name, Items = targetItem.Items };
                    newSubRow.Items.Add(oldItemClone);
                    newSubRow.Items.Add(itemToInsert);

                    var index = parent.Items.IndexOf(targetItem);
                    if(index != -1)
                        parent.Items[index] = newSubRow;
                }
            }
        }
        else // Lógica para Top, Bottom, Left, Right
        {
            var parent = targetItem.Parent;
            if(parent == null)
                return;

            var index = parent.Items.IndexOf(targetItem);
            if(index == -1)
                return;

            // Para "Bottom" y "Right", insertamos después del índice actual.
            if(dropPosition == "Bottom" || dropPosition == "Right")
            {
                index++;
            }

            parent.Items.Insert(index, itemToInsert);
        }
    }

    private void HandleDeleteItem(Guid itemId)
    {
        var rowToRemove = reportRows.FirstOrDefault(r => r.UniqueId == itemId);
        if(rowToRemove != null)
        {
            reportRows.Remove(rowToRemove);
        }
        else
        {
            var itemToDelete = FindItemById(itemId);
            if(itemToDelete?.Parent != null)
            {
                var parent = itemToDelete.Parent;
                parent.Items.Remove(itemToDelete);
                CleanupEmptyParent(parent);
            }
        }
        StateHasChanged();
    }

    private void CleanupEmptyParent(TemplateExecutionModel? parent)
    {
        if(parent != null && parent.Visualization == VisualizationType.Empty && !parent.HasChilds)
        {
            HandleDeleteItem(parent.UniqueId);
        }
    }

    private TemplateExecutionModel? FindItemById(Guid id)
    {
        foreach(var row in reportRows)
        {
            var found = FindInNode(row, id);
            if(found != null)
                return found;
        }
        return null;
    }

    private TemplateExecutionModel? FindInNode(TemplateExecutionModel node, Guid id)
    {
        if(node.UniqueId == id)
            return node;
        foreach(var child in node.Items)
        {
            var found = FindInNode(child, id);
            if(found != null)
                return found;
        }
        return null;
    }

    private bool IsDescendant(TemplateExecutionModel node, Guid idToFind)
    {
        return node.Items.Any(child => child.UniqueId == idToFind || IsDescendant(child, idToFind));
    }

    private void ClearReport()
    {
        reportRows.Clear();
        StateHasChanged();
    }

    public ValueTask DisposeAsync()
    {
        if(dotNetRef != null)
        {
            dotNetRef.Dispose();
        }
        return ValueTask.CompletedTask;
    }
}
